---
title: Writing Runners
description: Guide to creating custom runners
lastModified: 2025-11-26
---

This guide covers everything you need to know about writing effective runners.

## Basic Runner Structure

A runner is an async function that:
1. Has the `"use runner"` directive
2. Accepts `RunnerContext` and optional input 
3. Returns a `RunnerResult`

```typescript
import type { Runner } from "runners";

export const myRunner: Runner = async (ctx, input) => {
  "use runner";
  
  // Your logic here
  
  return {
    name: "my_runner",
    status: "pass", // or "fail" or "error"
    details: { /* optional */ },
  };
};
```

## The "use runner" Directive

The directive tells the discovery system that this function is a runner. It can be:

### Function-Level (Recommended)
```typescript
export const runner: Runner = async (ctx) => {
  "use runner";
  // Only this function is a runner
};
```

### Module-Level
```typescript
"use runner";

export const runner1: Runner = async (ctx) => {
  // All exported async functions are runners
};

export const runner2: Runner = async (ctx) => {
  // This is also a runner
};
```

**Best Practice**: Use function-level directives for clarity and to avoid accidentally marking helper functions as runners.

## Input and Output Validation

Runners support validation for both input and output using Zod or Standard Schema. Input schemas are validated at runtime, while output schemas provide TypeScript typing for the `details` field.

### Input Validation

Use Zod schemas to validate and type your input:

```typescript
import { z } from "zod";

const MyInputSchema = z.object({
  url: z.string().url(),
  timeout: z.number().positive().optional(),
});

export const validatedRunner: Runner<
  z.infer<typeof MyInputSchema>
> = async (ctx, input) => {
  "use runner";
  
  // input is typed and validated
  const url = input.url; // string
  const timeout = input.timeout; // number | undefined
};
```

The runner harness will automatically validate input against your schema before execution.

### Output Validation

Define output schemas to type the `details` field in your results:

```typescript
import { z } from "zod";

const MyInputSchema = z.object({
  url: z.string().url(),
});

const MyOutputSchema = z.object({
  title: z.string(),
  hasMeta: z.boolean(),
  h1Count: z.number(),
});

export const validatedRunner: Runner<
  z.infer<typeof MyInputSchema>,
  z.infer<typeof MyOutputSchema>
> = async (ctx, input) => {
  "use runner";
  
  const { page } = await withPlaywright(ctx, input.url);
  
  const title = await page.title();
  const hasMeta = await page.locator('meta[name="description"]').count() > 0;
  const h1Count = await page.locator("h1").count();
  
  // details is typed based on MyOutputSchema
  return {
    name: "validated_check",
    status: "pass",
    details: {
      title,        // string
      hasMeta,      // boolean
      h1Count,      // number
    },
  };
};
```

### Both Input and Output Schemas

You can define both schemas for complete type safety:

```typescript
import { z } from "zod";
import type { Runner } from "runners";

// Input schema
const CookieBannerInputSchema = z.object({
  url: z.string().url(),
  selector: z.string().optional(),
});

// Output schema
const CookieBannerOutputSchema = z.object({
  visible: z.boolean(),
  selector: z.string(),
  text: z.string().optional(),
});

export const cookieBannerTest: Runner<
  z.infer<typeof CookieBannerInputSchema>,
  z.infer<typeof CookieBannerOutputSchema>
> = async (ctx, input) => {
  "use runner";
  
  const { page } = await withPlaywright(ctx, input.url);
  const selector = input.selector || "[data-cookie-banner]";
  
  const banner = page.locator(selector).first();
  const visible = await banner.isVisible();
  const text = visible ? await banner.textContent() : undefined;
  
  return {
    name: "cookie_banner_check",
    status: visible ? "pass" : "fail",
    details: {
      visible,     // boolean (validated by output schema)
      selector,   // string
      text,       // string | undefined
    },
  };
};

// Export schemas for discovery (optional but recommended)
export const cookieBannerTestInputSchema = CookieBannerInputSchema;
export const cookieBannerTestOutputSchema = CookieBannerOutputSchema;
```

### Schema Discovery

The system automatically discovers schemas following naming conventions:

- **Input Schema**: `{runnerName}InputSchema`, `{runnerName}Schema`, or `InputSchema`
- **Output Schema**: `{runnerName}OutputSchema` or `OutputSchema`

For the example above:
- `cookieBannerTestInputSchema` → Input schema for `cookieBannerTest`
- `cookieBannerTestOutputSchema` → Output schema for `cookieBannerTest`

## Using Playwright

For browser automation, use `withPlaywright()`:

```typescript
import { withPlaywright } from "runners/playwright";

export const browserRunner: Runner = async (ctx, input) => {
  "use runner";
  
  const { page, url, region, log } = await withPlaywright(ctx, input.url);
  
  // Use Playwright page object
  await page.goto(url);
  const title = await page.title();
  
  return {
    name: "browser_check",
    status: "pass",
    details: { title },
  };
};
```

### Playwright Context

`withPlaywright()` returns:
- `page: Page` - Playwright page object
- `url: string` - The URL being tested
- `region?: string` - Region identifier
- `log: (message, meta?) => void` - Logging function
- `browser: Browser` - Browser instance (advanced)
- `context: BrowserContext` - Browser context (advanced)

### Browser Lifecycle

- Browser is launched automatically
- Context is created per runner
- Browser is closed after runner completes
- Errors automatically clean up resources

## Returning Results

### Result Structure

```typescript
type RunnerResult = {
  name: string;              // Required: unique identifier
  status: "pass" | "fail" | "error";  // Required
  details?: Record<string, unknown>;   // Optional: custom data
  errorMessage?: string;     // Optional: error details
  durationMs?: number;       // Optional: execution time
};
```

### Status Values

- **`"pass"`**: Test passed successfully
- **`"fail"`**: Test failed (expected failure, e.g., assertion failed)
- **`"error"`**: Unexpected error occurred (exception thrown)

### Example Results

```typescript
// Success
return {
  name: "title_check",
  status: "pass",
  details: { title: "Example" },
};

// Failure
return {
  name: "title_check",
  status: "fail",
  details: { expected: "Example", actual: "Wrong Title" },
};

// Error (usually from catch block)
return {
  name: "title_check",
  status: "error",
  errorMessage: "Failed to load page: timeout",
};
```

## Error Handling

### Throwing Errors

Thrown errors are automatically caught and converted to `error` status:

```typescript
export const errorRunner: Runner = async (ctx, input) => {
  "use runner";
  
  if (!input.url) {
    throw new Error("url is required");
  }
  
  // If this throws, it becomes status: "error"
  const response = await fetch(input.url);
};
```

### Explicit Error Results

For expected failures, return `fail` status:

```typescript
export const validationRunner: Runner = async (ctx, input) => {
  "use runner";
  
  const isValid = validateSomething(input);
  
  if (!isValid) {
    return {
      name: "validation_check",
      status: "fail",
      errorMessage: "Validation failed: ...",
    };
  }
  
  return {
    name: "validation_check",
    status: "pass",
  };
};
```

### Try-Catch Pattern

```typescript
export const robustRunner: Runner = async (ctx, input) => {
  "use runner";
  
  try {
    const result = await riskyOperation();
    return {
      name: "robust_check",
      status: "pass",
      details: { result },
    };
  } catch (error) {
    return {
      name: "robust_check",
      status: "error",
      errorMessage: error instanceof Error ? error.message : String(error),
    };
  }
};
```

## Logging

Use the `log` function from context:

```typescript
export const loggedRunner: Runner = async (ctx, input) => {
  "use runner";
  
  ctx.log("Starting check", { url: input.url });
  
  // ... do work ...
  
  ctx.log("Check complete", { result: "pass" });
  
  return { name: "logged_check", status: "pass" };
};
```

With Playwright:

```typescript
const { log } = await withPlaywright(ctx, input.url);

log("Page loaded", { url, region });
```

## Advanced Patterns

### Multiple Checks in One Runner

```typescript
export const multiCheckRunner: Runner = async (ctx, input) => {
  "use runner";
  
  const { page } = await withPlaywright(ctx, input.url);
  
  const checks = {
    hasTitle: false,
    hasMeta: false,
    hasH1: false,
  };
  
  checks.hasTitle = (await page.title()).length > 0;
  checks.hasMeta = (await page.locator('meta[name="description"]').count()) > 0;
  checks.hasH1 = (await page.locator("h1").count()) > 0;
  
  const allPassed = Object.values(checks).every(Boolean);
  
  return {
    name: "multi_check",
    status: allPassed ? "pass" : "fail",
    details: checks,
  };
};
```

### Conditional Logic

```typescript
export const conditionalRunner: Runner = async (ctx, input) => {
  "use runner";
  
  const { page } = await withPlaywright(ctx, input.url);
  
  // Check if mobile viewport
  if (input.viewport === "mobile") {
    await page.setViewportSize({ width: 375, height: 667 });
  }
  
  // ... rest of logic
};
```

### Timeouts

```typescript
export const timeoutRunner: Runner = async (ctx, input) => {
  "use runner";
  
  const timeout = input.timeout || 5000;
  
  const result = await Promise.race([
    doWork(),
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error("Timeout")), timeout)
    ),
  ]);
  
  return {
    name: "timeout_check",
    status: "pass",
    details: { result },
  };
};
```

### Async Operations

```typescript
export const asyncRunner: Runner = async (ctx, input) => {
  "use runner";
  
  const { page } = await withPlaywright(ctx, input.url);
  
  // Wait for element
  await page.waitForSelector(".content", { timeout: 10000 });
  
  // Wait for network
  await page.waitForLoadState("networkidle");
  
  // ... rest of logic
};
```

## Best Practices

### 1. Use Descriptive Names

```typescript
// Good
name: "cookie_banner_visible_check"

// Bad
name: "check1"
```

### 2. Provide Useful Details

```typescript
// Good
details: {
  visible: true,
  selector: "[data-cookie-banner]",
  duration: 1234,
}

// Bad
details: {} // Empty details
```

### 3. Validate Input Early

```typescript
export const validatedRunner: Runner = async (ctx, input) => {
  "use runner";
  
  if (!input?.url) {
    throw new Error("url is required");
  }
  
  // ... rest of logic
};
```

### 4. Use TypeScript Types

```typescript
// Good: Type-safe input and output
const InputSchema = z.object({ url: z.string().url() });
const OutputSchema = z.object({ title: z.string() });
export const runner: Runner<
  z.infer<typeof InputSchema>,
  z.infer<typeof OutputSchema>
> = async (ctx, input) => {
  // input.url is typed
  return {
    name: "runner",
    status: "pass",
    details: { title: "Example" }, // Typed by OutputSchema
  };
};

// Bad: Any input/output
export const runner: Runner = async (ctx, input: any) => {
  // No type safety
};
```

### 5. Handle Edge Cases

```typescript
export const robustRunner: Runner = async (ctx, input) => {
  "use runner";
  
  const { page } = await withPlaywright(ctx, input.url);
  
  try {
    const element = page.locator(input.selector).first();
    const count = await element.count();
    
    if (count === 0) {
      return {
        name: "element_check",
        status: "fail",
        errorMessage: `Element not found: ${input.selector}`,
      };
    }
    
    // ... rest of logic
  } catch (error) {
    return {
      name: "element_check",
      status: "error",
      errorMessage: error instanceof Error ? error.message : String(error),
    };
  }
};
```

### 6. Keep Runners Focused

```typescript
// Good: One focused check
export const titleCheck: Runner = async (ctx, input) => {
  "use runner";
  // Only checks title
};

// Bad: Too many responsibilities
export const everythingCheck: Runner = async (ctx, input) => {
  "use runner";
  // Checks title, meta, h1, h2, links, images, etc.
};
```

### 7. Use Helper Functions

```typescript
// Helper function (not a runner)
function extractMetaTags(page: Page) {
  return page.locator("meta").all();
}

export const metaCheck: Runner = async (ctx, input) => {
  "use runner";
  
  const { page } = await withPlaywright(ctx, input.url);
  const metaTags = await extractMetaTags(page);
  
  // ... use metaTags
};
```

## Testing Runners

Test your runners locally:

```bash
npx runners run --url https://example.com myRunner
```

Or programmatically:

```typescript
import { runRunners } from "runners";
import { myRunner } from "./runners";

const result = await runRunners({
  runners: [myRunner],
  region: "us-east-1",
});

console.log(result.results);
```

## Common Patterns

See the [examples](../examples/) directory for complete working examples of:
- Cookie banner checks
- Title validation
- Meta tag verification
- Form validation
- API checks
- And more

